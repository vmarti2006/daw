# SQL Insercions

En aquesta secció aprendrem a inserir files en una taula amb SQL. Ens centrarem en PostgreSQL (p. ex. Supabase), tot i que la sintaxi bàsica és molt similar a d'altres SGBD.

## Sintaxi bàsica

La forma més comuna és especificar les columnes i els seus valors amb `VALUES`:

```sql
INSERT INTO taula (col1, col2, col3)
VALUES (valor1, valor2, valor3);
```

- Si s'omet la llista de columnes, s'han de proporcionar valors per a totes les columnes, i en el mateix ordre en què van ser definides.
- És recomanable indicar sempre la llista de columnes per evitar errors quan canvia l'esquema.

Exemple amb una taula `clients(id SERIAL PRIMARY KEY, nom TEXT NOT NULL, email TEXT UNIQUE, alta DATE DEFAULT CURRENT_DATE)`:

```sql
INSERT INTO clients (nom, email)
VALUES ('Anna Puig', 'anna@example.com');
```

Com que `id` és generat automàticament i `alta` té un valor per defecte, podem ometre'ls.

## Tipus de valors i literals

- Text: useu cometes simples: `'text'`. Si cal incloure una cometa simple interna, dupliqueu-la: `'L''Anna'`.
- Nombres: sense cometes: `42`, `3.14`.
- Dates/hores: `'2025-10-25'`, `'2025-10-25 14:00:00'`. PostgreSQL les interpreta segons el tipus de la columna (`DATE`, `TIMESTAMP`, …).
- `NULL`: representa valor desconegut/absent. Només és vàlid si la columna no és `NOT NULL` o si un `DEFAULT` el substitueix.
- `DEFAULT`: força l'ús del valor per defecte de la columna.

```sql
INSERT INTO clients (nom, email, alta)
VALUES ('Joan', DEFAULT, '2025-10-25');
```

## Insercions múltiples

Podeu inserir diverses files en una sola instrucció `INSERT` separant tuples de `VALUES` per comes:

```sql
INSERT INTO clients (nom, email)
VALUES
	('Marta', 'marta@example.com'),
	('Pau',   'pau@example.com'),
	('Iris',  'iris@example.com');
```

Això és més eficient que executar molts `INSERT` d'una sola fila.

## Inserir a partir d'una consulta (INSERT … SELECT)

Permet copiar o transformar dades d'una altra taula (o consulta):

```sql
INSERT INTO clients_hist (client_id, nom, email, alta)
SELECT id, nom, email, alta
FROM clients
WHERE alta < '2024-01-01';
```

També podeu combinar amb funcions o agregacions dins del `SELECT`.

## Columnes autoincrementals (IDENTITY/SERIAL)

En PostgreSQL modern, es recomana `GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY`. A projectes existents també trobareu `SERIAL`.

```sql
CREATE TABLE productes (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	nom TEXT NOT NULL,
	preu NUMERIC(10,2) NOT NULL
);

INSERT INTO productes (nom, preu)
VALUES ('Teclat', 24.90);
```

No cal indicar l'`id`; el SGBD l'assigna automàticament.


## Restriccions i errors habituals

- `NOT NULL violation`: heu inserit `NULL` a una columna `NOT NULL` sense `DEFAULT`.
- `UNIQUE violation` o `duplicate key value violates unique constraint`: un valor ja existeix per a una columna única o clau primària.
- `FOREIGN KEY violation`: el valor referenciat no existeix a la taula pare.
- `CHECK constraint violation`: el valor no compleix una regla definida (`preu > 0`, etc.).
- Errors de tipus: intentar inserir `'abc'` a una columna numèrica, o una data amb format invàlid.

Llegiu sempre el missatge d'error; indica la columna, la restricció i el valor problemàtic.
---

# Introduint la clàusula WHERE

La clàusula `WHERE` en SQL permet filtrar les files que compleixen una condició determinada. És fonamental per recuperar només les dades que ens interessen d'una taula.

## Sintaxi bàsica

```sql
SELECT columnes
FROM taula
WHERE condició;
```

## Exemple senzill

Suposem que tenim una taula `alumnes` amb les columnes `nom`, `edat` i `curs`. Si volem obtenir els alumnes que tenen més de 18 anys:

```sql
SELECT nom, edat
FROM alumnes
WHERE edat > 18;
```

## Operadors comuns en WHERE

- `=`   Igualtat
- `<>`  Diferent
- `>`   Major que
- `<`   Menor que
- `>=`  Major o igual que
- `<=`  Menor o igual que
- `BETWEEN`  Entre dos valors
- `IN`  Dins d'un conjunt de valors
- `LIKE`  Cerca per patró
- `IS NULL`  Valor nul

## Exemple amb LIKE

```sql
SELECT nom
FROM alumnes
WHERE nom LIKE 'A%';
```

Aquest exemple retorna els noms dels alumnes que comencen per la lletra 'A'.

## Exemple amb IN

```sql
SELECT nom, curs
FROM alumnes
WHERE curs IN ('1r', '2n');
```

Retorna els alumnes que estan als cursos '1r' o '2n'.

## Exemple amb BETWEEN

```sql
SELECT nom, edat
FROM alumnes
WHERE edat BETWEEN 16 AND 18;
```

Retorna els alumnes amb edat entre 16 i 18 anys (inclosos).

## Exemple amb IS NULL

```sql
SELECT nom
FROM alumnes
WHERE curs IS NULL;
```

Retorna els alumnes que no tenen curs assignat.

## Combinació de condicions

Es poden combinar condicions amb `AND` i `OR`:

```sql
SELECT nom, edat
FROM alumnes
WHERE edat > 18 AND curs = '2n';
```
---

# Introduint la clàusula ORDER BY

La clàusula `ORDER BY` en SQL permet ordenar els resultats d'una consulta segons una o més columnes. És útil per presentar les dades de manera organitzada i facilitar la seva anàlisi.

## Sintaxi bàsica

```sql
SELECT columnes
FROM taula
ORDER BY columna [ASC|DESC];
```

- `ASC` (ascendent) és l'opció per defecte.
- `DESC` (descendent) ordena de major a menor.

## Exemple senzill

Suposem que tenim una taula `alumnes` amb les columnes `nom` i `edat`. Si volem obtenir la llista d'alumnes ordenada per edat de menor a major:

```sql
SELECT nom, edat
FROM alumnes
ORDER BY edat ASC;
```

Si volem la llista d'alumnes ordenada per edat de major a menor:

```sql
SELECT nom, edat
FROM alumnes
ORDER BY edat DESC;
```

## Ordenar per més d'una columna

Es pot ordenar per diverses columnes. Per exemple, primer per `curs` i després per `nom`:

```sql
SELECT nom, curs
FROM alumnes
ORDER BY curs ASC, nom ASC;
```

## Exemple amb WHERE i ORDER BY

```sql
SELECT nom, edat
FROM alumnes
WHERE edat > 18
ORDER BY nom;
```

Aquest exemple retorna els alumnes majors de 18 anys ordenats alfabèticament pel nom.

---

# Introduint funcions d'agregació en SQL

Les funcions d'agregació permeten realitzar càlculs sobre un conjunt de files i retornar un únic valor resum. Són molt útils per obtenir estadístiques i resums de dades.

## Principals funcions d'agregació

- `COUNT()`  Comptar el nombre de files
- `SUM()`    Sumar valors d'una columna
- `AVG()`    Calcular la mitjana
- `MIN()`    Trobar el valor mínim
- `MAX()`    Trobar el valor màxim

## Exemple amb COUNT

Comptar el nombre d'alumnes:

```sql
SELECT COUNT(*)
FROM alumnes;
```

## Exemple amb SUM

Sumar les edats de tots els alumnes:

```sql
SELECT SUM(edat)
FROM alumnes;
```

## Exemple amb AVG

Mitjana d'edat dels alumnes:

```sql
SELECT AVG(edat)
FROM alumnes;
```

## Exemple amb MIN i MAX

Trobar l'edat mínima i màxima:

```sql
SELECT MIN(edat), MAX(edat)
FROM alumnes;
```

## Utilització amb WHERE

Les funcions d'agregació es poden combinar amb la clàusula WHERE per filtrar les files abans de calcular l'agregat:

```sql
SELECT COUNT(*)
FROM alumnes
WHERE curs = '2n';
```
---

# Introduint la clàusula GROUP BY en SQL

La clàusula `GROUP BY` permet agrupar files que tenen el mateix valor en una o més columnes. S'utilitza principalment amb funcions d'agregació per obtenir resultats resumits per grups.

## Sintaxi bàsica

```sql
SELECT columna, funció_agregació(columna)
FROM taula
GROUP BY columna;
```

## Exemple senzill

Suposem que tenim una taula `alumnes` amb les columnes `curs` i `edat`. Si volem saber quants alumnes hi ha per cada curs:

```sql
SELECT curs, COUNT(*)
FROM alumnes
GROUP BY curs;
```

## Exemple amb SUM

Sumar les edats dels alumnes per curs:

```sql
SELECT curs, SUM(edat)
FROM alumnes
GROUP BY curs;
```

## Exemple amb més d'una columna

Es pot agrupar per més d'una columna:

```sql
SELECT curs, edat, COUNT(*)
FROM alumnes
GROUP BY curs, edat;
```

## Utilització amb WHERE

La clàusula WHERE filtra les files abans d'agrupar-les:

```sql
SELECT curs, COUNT(*)
FROM alumnes
WHERE edat > 18
GROUP BY curs;
```

## Punt important: columnes i GROUP BY

És molt important recordar que **totes les columnes que apareixen al SELECT i que no estan dins d'una funció d'agregació** (com COUNT, SUM, AVG, MIN, MAX...) **han d'aparèixer també al GROUP BY**.

### Motiu

Quan utilitzem GROUP BY, SQL agrupa les files segons els valors de les columnes indicades. Si posem al SELECT una columna que no està agregada ni al GROUP BY, el sistema no sabrà com agrupar correctament aquests valors, ja que podrien ser diferents dins el mateix grup. Això genera un error perquè SQL no pot decidir quin valor mostrar per cada grup.

### Exemple incorrecte

```sql
SELECT curs, edat, COUNT(*)
FROM alumnes
GROUP BY curs;
```

En aquest cas, `edat` no està agregada ni al GROUP BY. Si hi ha diverses edats per cada curs, SQL no pot saber quina edat mostrar per cada grup de `curs`.

### Exemple correcte

```sql
SELECT curs, COUNT(*)
FROM alumnes
GROUP BY curs;
```

O bé, si volem agrupar per curs i edat:

```sql
SELECT curs, edat, COUNT(*)
FROM alumnes
GROUP BY curs, edat;
```
---

# Introduint la clàusula HAVING en SQL

La clàusula `HAVING` permet filtrar els resultats després d'aplicar la clàusula `GROUP BY`. És similar a `WHERE`, però s'utilitza per posar condicions sobre els grups i els resultats de funcions d'agregació.

## Diferència entre WHERE i HAVING
- `WHERE` filtra les files abans d'agrupar-les.
- `HAVING` filtra els grups després d'aplicar `GROUP BY`.

## Sintaxi bàsica

```sql
SELECT columna, funció_agregació(columna)
FROM taula
GROUP BY columna
HAVING condició;
```

## Exemple senzill

Suposem que volem saber quins cursos tenen més de 5 alumnes:

```sql
SELECT curs, COUNT(*) AS num_alumnes
FROM alumnes
GROUP BY curs
HAVING COUNT(*) > 5;
```

## Exemple amb SUM

Cursos on la suma de les edats supera 100:

```sql
SELECT curs, SUM(edat) AS suma_edats
FROM alumnes
GROUP BY curs
HAVING SUM(edat) > 100;
```

## Exemple combinat amb WHERE

Primer filtrem alumnes majors de 18 anys, després agrupem i filtrem grups:

```sql
SELECT curs, COUNT(*)
FROM alumnes
WHERE edat > 18
GROUP BY curs
HAVING COUNT(*) > 2;
```
---

# Conceptes d'àlgebra relacional (producte cartesià)

## Introducció

Després d'aprendre sobre operacions unàries (selecció i projecció) i haver practicat amb consultes bàsiques SQL, ara estudiarem les operacions **binàries** de l'àlgebra relacional, que combinen dues relacions.

En aquesta sessió ens centrarem en el **producte cartesià**, que és l'operació més bàsica per combinar dues taules i que serveix de base per entendre els JOIN.

## Producte cartesià (×)

El **producte cartesià** combina cada fila d'una relació amb cada fila d'una altra relació. És una operació **binària**.

**Notació:** Relació1 × Relació2

### Exemple conceptual

Si tenim:
- **Clients** amb 3 files
- **Productes** amb 5 files

El producte cartesià **Clients × Productes** generarà 3 × 5 = **15 files**.

### Exemple amb dades

**Taula Clients:**
| id | nom    | ciutat    |
|----|--------|-----------|
| 1  | Anna   | Barcelona |
| 2  | Bernat | Girona    |

**Taula Productes:**
| id | nom      | preu |
|----|----------|------|
| 10 | Portàtil | 800  |
| 20 | Ratolí   | 15   |

**Clients × Productes:**
| Clients.id | Clients.nom | Clients.ciutat | Productes.id | Productes.nom | Productes.preu |
|------------|-------------|----------------|--------------|---------------|----------------|
| 1          | Anna        | Barcelona      | 10           | Portàtil      | 800            |
| 1          | Anna        | Barcelona      | 20           | Ratolí        | 15             |
| 2          | Bernat      | Girona         | 10           | Portàtil      | 800            |
| 2          | Bernat      | Girona         | 20           | Ratolí        | 15             |

### Equivalent SQL

```sql
-- Sintaxi tradicional
SELECT * FROM Clients, Productes;

-- Sintaxi moderna (més explícita)
SELECT * FROM Clients CROSS JOIN Productes;
```

### Característiques

- **Nombre de files resultants:** |R1| × |R2| (producte del nombre de files)
- **Nombre de columnes resultants:** suma de columnes de les dues taules
- **No hi ha condició de join:** totes les combinacions possibles
- **Pot generar taules molt grans:** cal anar amb compte amb taules grans

### Quan s'utilitza?

El producte cartesià pur s'utilitza rarament en la pràctica perquè:
- Genera moltes files (sovint massa)
- La majoria de combinacions no tenen sentit

Però és útil per:
1. **Comprendre la base teòrica** dels JOIN
2. **Generar combinacions** en casos específics
3. **Calendaris o planificacions** (tots els dies × totes les franges horàries)

## Producte cartesià amb selecció

El producte cartesià es fa útil quan el combinem amb una selecció per filtrar només les files rellevants:

**Expressió d'àlgebra relacional:**
σ<sub>Clients.id = Comandes.client_id</sub>(Clients × Comandes)

**Equivalent SQL:**
```sql
SELECT *
FROM Clients, Comandes
WHERE Clients.id = Comandes.client_id;
```

Això és essencialment un **JOIN**, que veurem en detall en la propera sessió.

## Exemple pràctic

### Cas d'ús: Llistat de disponibilitat

Imaginem que volem crear un calendari amb totes les possibles cites entre doctors i pacients:

**Doctors:**
| id | nom        |
|----|------------|
| 1  | Dr. Martí  |
| 2  | Dra. Silva |

**Pacients:**
| id | nom   |
|----|-------|
| 10 | Joan  |
| 20 | Maria |

**Doctors × Pacients:**
| doctor_id | doctor_nom | pacient_id | pacient_nom |
|-----------|------------|------------|-------------|
| 1         | Dr. Martí  | 10         | Joan        |
| 1         | Dr. Martí  | 20         | Maria       |
| 2         | Dra. Silva | 10         | Joan        |
| 2         | Dra. Silva | 20         | Maria       |

Després podríem afegir dates i hores per crear un calendari complet de disponibilitat.

## Propietats del producte cartesià

### Commutativitat
R × S ≠ S × R (tècnicament)

Nota: El resultat conté les mateixes dades però l'ordre de les columnes és diferent.

### Associativitat
(R × S) × T = R × (S × T)

Podem fer productes cartesians de múltiples taules en qualsevol ordre.

### Relació amb altres operacions

**Producte cartesià + Selecció = Join**
σ<sub>condició</sub>(R × S) ≡ R ⋈<sub>condició</sub> S

## Problemes de rendiment

⚠️ **ADVERTÈNCIA:** El producte cartesià pot ser molt costós:

- Clients amb 1.000 files × Productes amb 10.000 files = **10.000.000 de files!**
- Això pot bloquejar la base de dades
- Sempre hauríem d'utilitzar JOINs amb condicions en lloc de productes cartesians purs

## Exercicis pràctics

1. Si tenim una taula **Colors** amb 5 files i una taula **Mides** amb 4 files, quantes files tindrà Colors × Mides?

2. Escriu en àlgebra relacional: "Troba totes les combinacions de productes i proveïdors"

3. Escriu l'equivalent SQL del següent:
   π<sub>Clients.nom, Productes.nom</sub>(Clients × Productes)

4. Per què el següent és millor que un producte cartesià pur?
   ```sql
   SELECT * FROM Clients, Comandes
   WHERE Clients.id = Comandes.client_id;
   ```

## Resum

En aquesta sessió hem après:
- El **producte cartesià** combina totes les files de dues taules
- Genera |R1| × |R2| files
- Rarament s'utilitza sol en la pràctica
- És la base teòrica dels **JOIN**, que estudiarem a continuació
- Cal vigilar amb el rendiment

---


# Introduint Joins en SQL

Els joins permeten combinar dades de dues o més taules relacionades. Són fonamentals per treballar amb bases de dades relacionals i obtenir informació de diverses fonts.

## Tipus principals de JOIN

### 1. INNER JOIN

Retorna només les files que tenen coincidència a les dues taules.

```sql
SELECT a.nom, b.nom_curs
FROM alumnes a
INNER JOIN cursos b ON a.curs_id = b.id;
```

### 2. LEFT OUTER JOIN

Retorna totes les files de la taula de l'esquerra i les coincidències de la dreta. Si no hi ha coincidència, les columnes de la dreta seran NULL.

```sql
SELECT a.nom, b.nom_curs
FROM alumnes a
LEFT OUTER JOIN cursos b ON a.curs_id = b.id;
```

### 3. RIGHT OUTER JOIN

Retorna totes les files de la taula de la dreta i les coincidències de l'esquerra. Si no hi ha coincidència, les columnes de l'esquerra seran NULL.

```sql
SELECT a.nom, b.nom_curs
FROM alumnes a
RIGHT OUTER JOIN cursos b ON a.curs_id = b.id;
```


### 4. CROSS JOIN

Retorna el producte cartesià de les dues taules: totes les combinacions possibles de files.

```sql
SELECT a.nom, b.nom_curs
FROM alumnes a
CROSS JOIN cursos b;
```

## Exemples amb gossos i raça

Suposem les taules següents:

- `gossos(num_xip, nom, raça)`
- `raça(id, nom)`

La columna `raça` de `gossos` és una clau forana cap a `raça.id`.

### INNER JOIN
Obtenir el nom del gos i el nom de la raça (només gossos amb raça definida):

```sql
SELECT g.nom AS nom_gos, r.nom AS nom_raça
FROM gossos g
INNER JOIN raça r ON g.raça = r.id;
```

### LEFT OUTER JOIN
Obtenir tots els gossos, amb el nom de la raça si en tenen:

```sql
SELECT g.nom AS nom_gos, r.nom AS nom_raça
FROM gossos g
LEFT OUTER JOIN raça r ON g.raça = r.id;
```
Els gossos sense raça definida tindran `nom_raça` a NULL.

### RIGHT OUTER JOIN
Obtenir totes les races, amb el nom del gos si existeix:

```sql
SELECT g.nom AS nom_gos, r.nom AS nom_raça
FROM gossos g
RIGHT OUTER JOIN raça r ON g.raça = r.id;
```
Les races sense cap gos tindran `nom_gos` a NULL.


## Resum

- **INNER JOIN**: només coincidències a ambdues taules.
- **LEFT OUTER JOIN**: totes les files de l'esquerra, coincidències de la dreta.
- **RIGHT OUTER JOIN**: totes les files de la dreta, coincidències de l'esquerra.
- **CROSS JOIN**: totes les combinacions possibles.

---

# Conceptes d'àlgebra relacional (unions, interseccions, diferències)

## Introducció

Després d'aprendre sobre operacions unàries (selecció i projecció) i operacions que combinen taules diferents (producte cartesià i joins), ara estudiarem les **operacions de conjunts** de l'àlgebra relacional.

Aquestes operacions tracten les relacions com a conjunts matemàtics i permeten combinar, comparar i contrastar dades de taules amb la mateixa estructura.

## Requisit de compatibilitat

Per aplicar operacions de conjunts, les dues relacions han de ser **compatibles**:
- Han de tenir el **mateix nombre de columnes**
- Les columnes corresponents han de tenir **tipus de dades compatibles**
- Els noms de les columnes no cal que coincideixin (però és recomanable)

## Operacions de conjunts

### 1. Unió (∪)

La **unió** combina files de dues relacions, eliminant duplicats automàticament.

**Notació:** Relació1 ∪ Relació2

#### Exemple

**ClientsBCN:**
| id | nom   | ciutat    |
|----|-------|-----------|
| 1  | Anna  | Barcelona |
| 2  | Marc  | Barcelona |

**ClientsGIR:**
| id | nom    | ciutat |
|----|--------|--------|
| 3  | Laura  | Girona |
| 1  | Anna   | Girona |

**ClientsBCN ∪ ClientsGIR:**
| id | nom   | ciutat    |
|----|-------|-----------|
| 1  | Anna  | Barcelona |
| 2  | Marc  | Barcelona |
| 3  | Laura | Girona    |
| 1  | Anna  | Girona    |

**Equivalent SQL:**
```sql
SELECT * FROM ClientsBCN
UNION
SELECT * FROM ClientsGIR;
```

#### Característiques
- Elimina files **completament duplicades**
- Nombre de files: entre max(|R1|, |R2|) i |R1| + |R2|
- És **commutativa**: R ∪ S = S ∪ R
- És **associativa**: (R ∪ S) ∪ T = R ∪ (S ∪ T)

#### UNION ALL en SQL

Si volem mantenir duplicats:
```sql
SELECT * FROM ClientsBCN
UNION ALL
SELECT * FROM ClientsGIR;
```

### 2. Intersecció (∩)

La **intersecció** retorna només les files que estan presents en **ambdues** relacions.

**Notació:** Relació1 ∩ Relació2

#### Exemple

**ClientsOnline:**
| id | nom   | email           |
|----|-------|-----------------|
| 1  | Anna  | anna@mail.com   |
| 2  | Marc  | marc@mail.com   |
| 3  | Laura | laura@mail.com  |

**ClientsBotiga:**
| id | nom   | email           |
|----|-------|-----------------|
| 1  | Anna  | anna@mail.com   |
| 3  | Laura | laura@mail.com  |
| 4  | Pere  | pere@mail.com   |

**ClientsOnline ∩ ClientsBotiga:**
| id | nom   | email          |
|----|-------|----------------|
| 1  | Anna  | anna@mail.com  |
| 3  | Laura | laura@mail.com |

Aquests són els clients que han comprat tant online com a la botiga física.

**Equivalent SQL:**
```sql
SELECT * FROM ClientsOnline
INTERSECT
SELECT * FROM ClientsBotiga;
```

#### Característiques
- Només files que apareixen a **totes dues** taules
- Nombre de files: entre 0 i min(|R1|, |R2|)
- És **commutativa**: R ∩ S = S ∩ R
- És **associativa**: (R ∩ S) ∩ T = R ∩ (S ∩ T)

### 3. Diferència (−)

La **diferència** retorna les files que estan a la **primera** relació però **no** a la segona.

**Notació:** Relació1 − Relació2

#### Exemple

Utilitzant les mateixes taules de l'exemple anterior:

**ClientsOnline − ClientsBotiga:**
| id | nom  | email         |
|----|------|---------------|
| 2  | Marc | marc@mail.com |

Aquest és Marc, que només ha comprat online.

**ClientsBotiga − ClientsOnline:**
| id | nom  | email         |
|----|------|---------------|
| 4  | Pere | pere@mail.com |

Aquest és Pere, que només ha comprat a la botiga física.

**Equivalent SQL:**
```sql
-- Clients que només han comprat online
SELECT * FROM ClientsOnline
EXCEPT
SELECT * FROM ClientsBotiga;

-- Clients que només han comprat a la botiga
SELECT * FROM ClientsBotiga
EXCEPT
SELECT * FROM ClientsOnline;
```

#### Característiques
- **NO és commutativa**: R − S ≠ S − R
- **NO és associativa**: (R − S) − T ≠ R − (S − T)
- Nombre de files: entre 0 i |R1|

## Casos d'ús pràctics

### Exemple 1: Campanyes de màrqueting

```sql
-- Clients que han comprat aquest any però no l'any passat (nous clients)
SELECT client_id FROM Compres2024
EXCEPT
SELECT client_id FROM Compres2023;

-- Clients que hem perdut (van comprar l'any passat però no aquest)
SELECT client_id FROM Compres2023
EXCEPT
SELECT client_id FROM Compres2024;
```

### Exemple 2: Gestió d'inventari

```sql
-- Productes disponibles a Barcelona i Madrid
SELECT producte_id FROM StockBarcelona
INTERSECT
SELECT producte_id FROM StockMadrid;

-- Tots els productes en algun magatzem
SELECT producte_id FROM StockBarcelona
UNION
SELECT producte_id FROM StockMadrid
UNION
SELECT producte_id FROM StockValencia;
```

### Exemple 3: Control d'accés

```sql
-- Usuaris que tenen permisos d'admin o editor
SELECT user_id FROM Admins
UNION
SELECT user_id FROM Editors;

-- Usuaris que són admins però no editors
SELECT user_id FROM Admins
EXCEPT
SELECT user_id FROM Editors;
```

## Propietats de les operacions de conjunts

### Lleis de De Morgan
- NOT (R ∪ S) ≡ (NOT R) ∩ (NOT S)
- NOT (R ∩ S) ≡ (NOT R) ∪ (NOT S)

### Distributivitat
- R ∩ (S ∪ T) = (R ∩ S) ∪ (R ∩ T)
- R ∪ (S ∩ T) = (R ∪ S) ∩ (R ∪ T)

### Identitats
- R ∪ ∅ = R (la unió amb el conjunt buit)
- R ∩ ∅ = ∅ (la intersecció amb el conjunt buit)
- R ∪ R = R (idempotència de la unió)
- R ∩ R = R (idempotència de la intersecció)

## Combinació amb altres operacions

Les operacions de conjunts es poden combinar amb selecció i projecció:

**Exemple:**
π<sub>nom</sub>(σ<sub>ciutat='Barcelona'</sub>(ClientsActius)) ∪ π<sub>nom</sub>(σ<sub>ciutat='Barcelona'</sub>(ClientsInactius))

Això ens dona tots els noms de clients de Barcelona, siguin actius o inactius.

**Equivalent SQL:**
```sql
SELECT nom FROM ClientsActius WHERE ciutat = 'Barcelona'
UNION
SELECT nom FROM ClientsInactius WHERE ciutat = 'Barcelona';
```

## Diferència entre SQL i àlgebra relacional pura

En àlgebra relacional pura:
- **Les operacions sempre eliminen duplicats**

En SQL:
- **UNION** elimina duplicats (com l'àlgebra relacional)
- **UNION ALL** manté duplicats (extensió de SQL)
- **INTERSECT** i **EXCEPT** eliminen duplicats

## Exercicis pràctics

1. Tenim dues taules: **ProductesEuropa** i **ProductesAsia**. Escriu consultes per:
   - Tots els productes disponibles globalment
   - Productes només a Europa
   - Productes en tots dos continents

2. Explica la diferència entre:
   ```sql
   SELECT * FROM T1 UNION SELECT * FROM T2
   ```
   i
   ```sql
   SELECT * FROM T1 UNION ALL SELECT * FROM T2
   ```

3. Si |ClientsVIP| = 500 i |ClientsNormals| = 10.000, i sabem que tots els VIP també són normals, quantes files tindrà:
   - ClientsVIP ∪ ClientsNormals
   - ClientsVIP ∩ ClientsNormals
   - ClientsNormals − ClientsVIP

4. Escriu en àlgebra relacional: "Estudiants que han aprovat Matemàtiques però no Física"

## Resum

En aquesta sessió hem après:
- La **unió** (∪) combina files de dues taules eliminant duplicats
- La **intersecció** (∩) retorna files comunes a ambdues taules
- La **diferència** (−) retorna files de la primera taula que no estan a la segona
- Totes aquestes operacions requereixen **compatibilitat de taules**
- SQL proporciona **UNION**, **INTERSECT** i **EXCEPT**
- Són útils per **anàlisi comparativa** i **segmentació de dades**

---

# Subconsultes en SQL

## Introducció

Les **subconsultes** (o subqueries) són consultes SQL que s'inclouen dins d'una altra consulta. Són una eina poderosa que permet resoldre problemes complexos descomponent-los en parts més simples.

Una subconsulta és essencialment una consulta SELECT que apareix dins de:
- La clàusula WHERE
- La clàusula FROM
- La clàusula SELECT
- La clàusula HAVING

Les subconsultes permeten fer consultes dinàmiques on els criteris de filtrat depenen dels resultats d'altres consultes.

## Sintaxi bàsica

```sql
SELECT columnes
FROM taula
WHERE columna operador (SELECT columna FROM taula WHERE condició);
```

La subconsulta va entre parèntesis i s'executa abans que la consulta principal.

## Tipus de subconsultes

### 1. Subconsultes que retornen un sol valor (escalar)

Aquestes subconsultes retornen un únic valor i es poden utilitzar amb operadors de comparació (`=`, `>`, `<`, etc.).

#### Exemple 1: Trobar productes més cars que la mitjana

```sql
SELECT nom, preu
FROM Productes
WHERE preu > (SELECT AVG(preu) FROM Productes);
```

**Explicació:**
1. Primer s'executa `SELECT AVG(preu) FROM Productes` → retorna, per exemple, 250
2. Després s'executa la consulta principal: `WHERE preu > 250`

#### Exemple 2: Trobar l'empleat amb el salari més alt

```sql
SELECT nom, cognom, salari
FROM Empleats
WHERE salari = (SELECT MAX(salari) FROM Empleats);
```

### 2. Subconsultes que retornen múltiples valors

Quan la subconsulta pot retornar més d'un valor, utilitzem operadors especials com `IN`, `ANY`, `ALL`.

#### Operador IN

Comprova si un valor està dins d'un conjunt de valors.

```sql
-- Trobar clients que han fet comandes
SELECT nom, cognom
FROM Clients
WHERE id IN (SELECT client_id FROM Comandes);
```

**Equivalent amb JOIN:**
```sql
SELECT DISTINCT c.nom, c.cognom
FROM Clients c
INNER JOIN Comandes co ON c.id = co.client_id;
```

#### Exemple: Productes de categories específiques

```sql
-- Trobar productes de categories amb més de 10 productes
SELECT nom, categoria_id
FROM Productes
WHERE categoria_id IN (
    SELECT id
    FROM Categories
    WHERE (SELECT COUNT(*) FROM Productes WHERE categoria_id = Categories.id) > 10
);
```

#### Operador ANY

Comprova si la condició és certa per ALMENYS UN dels valors retornats.

```sql
-- Trobar productes més cars que QUALSEVOL producte de la categoria 'Ofertes'
SELECT nom, preu
FROM Productes
WHERE preu > ANY (
    SELECT preu
    FROM Productes
    WHERE categoria = 'Ofertes'
);
```

Això és equivalent a ser més car que el producte MÉS BARAT de 'Ofertes'.

#### Operador ALL

Comprova si la condició és certa per TOTS els valors retornats.

```sql
-- Trobar productes més cars que TOTS els productes de la categoria 'Ofertes'
SELECT nom, preu
FROM Productes
WHERE preu > ALL (
    SELECT preu
    FROM Productes
    WHERE categoria = 'Ofertes'
);
```

Això és equivalent a ser més car que el producte MÉS CAR de 'Ofertes'.

### 3. Subconsultes correlacionades

Una subconsulta correlacionada fa referència a columnes de la consulta externa. S'executa una vegada per cada fila de la consulta externa.

#### Exemple: Empleats que guanyen més que la mitjana del seu departament

```sql
SELECT nom, cognom, departament, salari
FROM Empleats e1
WHERE salari > (
    SELECT AVG(salari)
    FROM Empleats e2
    WHERE e2.departament = e1.departament
);
```

**Explicació:**
- Per cada empleat de la consulta externa, la subconsulta calcula la mitjana salarial del seu departament
- Es compara el salari de l'empleat amb aquesta mitjana

#### Exemple: Productes més cars de cada categoria

```sql
SELECT nom, categoria, preu
FROM Productes p1
WHERE preu = (
    SELECT MAX(preu)
    FROM Productes p2
    WHERE p2.categoria = p1.categoria
);
```

### 4. Subconsultes a la clàusula FROM

Les subconsultes poden actuar com a taules temporals.

```sql
-- Trobar categories amb preu mitjà superior a 100
SELECT categoria, preu_mitjà
FROM (
    SELECT categoria, AVG(preu) AS preu_mitjà
    FROM Productes
    GROUP BY categoria
) AS categories_mitjanes
WHERE preu_mitjà > 100;
```

**Important:** Quan utilitzem una subconsulta a FROM, hem de donar-li un àlies.

#### Exemple complex: Vendes per trimestre

```sql
SELECT trimestre, SUM(total) AS vendes_totals
FROM (
    SELECT 
        CASE 
            WHEN MONTH(data) BETWEEN 1 AND 3 THEN 'Q1'
            WHEN MONTH(data) BETWEEN 4 AND 6 THEN 'Q2'
            WHEN MONTH(data) BETWEEN 7 AND 9 THEN 'Q3'
            ELSE 'Q4'
        END AS trimestre,
        import AS total
    FROM Comandes
) AS comandes_per_trimestre
GROUP BY trimestre;
```

### 5. Subconsultes a la clàusula SELECT

Podem utilitzar subconsultes per calcular valors per cada fila del resultat.

```sql
SELECT 
    nom,
    preu,
    (SELECT AVG(preu) FROM Productes) AS preu_mitjà,
    preu - (SELECT AVG(preu) FROM Productes) AS diferència_mitjana
FROM Productes;
```

#### Exemple: Comptar comandes per client

```sql
SELECT 
    c.nom,
    c.cognom,
    (SELECT COUNT(*) 
     FROM Comandes co 
     WHERE co.client_id = c.id) AS num_comandes
FROM Clients c;
```

## Operador EXISTS

L'operador `EXISTS` comprova si una subconsulta retorna almenys una fila. Retorna TRUE o FALSE.

```sql
-- Trobar clients que han fet almenys una comanda
SELECT nom, cognom
FROM Clients c
WHERE EXISTS (
    SELECT 1
    FROM Comandes co
    WHERE co.client_id = c.id
);
```

**Nota:** Dins d'EXISTS, és comú utilitzar `SELECT 1` perquè només importa si hi ha files, no quins valors retorna.

### NOT EXISTS

Podem utilitzar `NOT EXISTS` per trobar files que NO compleixen la condició.

```sql
-- Trobar clients que NO han fet cap comanda
SELECT nom, cognom
FROM Clients c
WHERE NOT EXISTS (
    SELECT 1
    FROM Comandes co
    WHERE co.client_id = c.id
);
```

#### Exemple: Productes sense vendes

```sql
SELECT nom, codi
FROM Productes p
WHERE NOT EXISTS (
    SELECT 1
    FROM LíniesComanda lc
    WHERE lc.producte_id = p.id
);
```

## Comparació: Subconsultes vs JOINs

Moltes subconsultes es poden reescriure amb JOINs i viceversa.

### Exemple: Mateix resultat amb ambdós mètodes

**Amb subconsulta:**
```sql
SELECT nom, cognom
FROM Clients
WHERE id IN (SELECT client_id FROM Comandes);
```

**Amb JOIN:**
```sql
SELECT DISTINCT c.nom, c.cognom
FROM Clients c
INNER JOIN Comandes co ON c.id = co.client_id;
```

### Quan utilitzar subconsultes vs JOINs?

**Subconsultes són preferibles quan:**
- La lògica és més clara i llegible
- Necessitem EXISTS/NOT EXISTS
- Volem comparar amb agregacions (MAX, AVG, etc.)
- La subconsulta retorna un únic valor

**JOINs són preferibles quan:**
- Necessitem columnes de múltiples taules
- Millor rendiment (en alguns casos)
- Operacions més complexes de combinació

## Subconsultes amb HAVING

Podem utilitzar subconsultes a la clàusula HAVING per filtrar grups.

```sql
-- Trobar categories amb més productes que la categoria 'Electrònica'
SELECT categoria, COUNT(*) AS num_productes
FROM Productes
GROUP BY categoria
HAVING COUNT(*) > (
    SELECT COUNT(*)
    FROM Productes
    WHERE categoria = 'Electrònica'
);
```

## Exemples pràctics amb gossos i races

Assumint les taules:
- `gossos(num_xip, nom, raça, data_naixement)`
- `raça(id, nom, tamany)`

### Exemple 1: Gossos de la raça més popular

```sql
SELECT nom, raça
FROM gossos
WHERE raça = (
    SELECT raça
    FROM gossos
    GROUP BY raça
    ORDER BY COUNT(*) DESC
    LIMIT 1
);
```

### Exemple 2: Gossos més grans que la mitjana de la seva raça

```sql
SELECT g1.nom, g1.raça, g1.data_naixement
FROM gossos g1
WHERE g1.data_naixement < (
    SELECT AVG(g2.data_naixement)
    FROM gossos g2
    WHERE g2.raça = g1.raça
);
```

### Exemple 3: Races que tenen més de 5 gossos

```sql
SELECT nom
FROM raça
WHERE id IN (
    SELECT raça
    FROM gossos
    GROUP BY raça
    HAVING COUNT(*) > 5
);
```

### Exemple 4: Gossos de races de tamany gran

```sql
SELECT nom, num_xip
FROM gossos
WHERE raça IN (
    SELECT id
    FROM raça
    WHERE tamany = 'Gran'
);
```

## Subconsultes imbricades

Podem tenir subconsultes dins de subconsultes (fins a diversos nivells, tot i que pot afectar el rendiment).

```sql
-- Trobar productes de la mateixa categoria que el producte més car
SELECT nom, categoria, preu
FROM Productes
WHERE categoria = (
    SELECT categoria
    FROM Productes
    WHERE preu = (
        SELECT MAX(preu)
        FROM Productes
    )
);
```

## Consideracions de rendiment

1. **Les subconsultes correlacionades** poden ser lentes perquè s'executen múltiples vegades
2. En molts casos, els **JOINs són més eficients** que les subconsultes
3. Utilitzar **EXISTS** en lloc de **IN** pot ser més ràpid amb grans volums de dades
4. Amb **PostgreSQL i MySQL moderns**, l'optimitzador sovint converteix subconsultes en JOINs automàticament

### Optimització: EXISTS vs IN

**Menys eficient amb moltes dades:**
```sql
SELECT nom FROM Clients
WHERE id IN (SELECT client_id FROM Comandes);
```

**Més eficient:**
```sql
SELECT nom FROM Clients c
WHERE EXISTS (SELECT 1 FROM Comandes co WHERE co.client_id = c.id);
```

## Errors comuns

### ❌ Error 1: Subconsulta retorna més d'un valor

```sql
-- ERROR si hi ha més d'un empleat amb salari màxim
SELECT nom
FROM Empleats
WHERE departament = (SELECT departament FROM Empleats WHERE salari > 50000);
```

**Solució:** Utilitzar IN en lloc de =
```sql
SELECT nom
FROM Empleats
WHERE departament IN (SELECT departament FROM Empleats WHERE salari > 50000);
```

### ❌ Error 2: Oblidar l'àlies en subconsulta a FROM

```sql
-- ERROR: falta àlies
SELECT categoria, preu_mitjà
FROM (SELECT categoria, AVG(preu) AS preu_mitjà FROM Productes GROUP BY categoria);
```

**Solució:**
```sql
SELECT categoria, preu_mitjà
FROM (SELECT categoria, AVG(preu) AS preu_mitjà FROM Productes GROUP BY categoria) AS t;
```

### ❌ Error 3: Comparar amb NULL incorrectament

```sql
-- NO funciona si la subconsulta retorna NULL
WHERE columna = (SELECT ... );
```

**Solució:** Utilitzar IS NULL o COALESCE
```sql
WHERE columna = COALESCE((SELECT ... ), valor_per_defecte);
```

## Exercicis pràctics

Assumeix les següents taules:

**Taula Empleats:**
| id | nom    | cognom  | departament | salari | supervisor_id |
|----|--------|---------|-------------|--------|---------------|
| 1  | Anna   | Garcia  | Vendes      | 30000  | NULL          |
| 2  | Marc   | Lopez   | IT          | 45000  | 1             |
| 3  | Laura  | Martí   | IT          | 42000  | 1             |
| 4  | Pere   | Vila    | Vendes      | 32000  | 1             |
| 5  | Joan   | Puig    | Vendes      | 28000  | 4             |

**Taula Departaments:**
| id | nom        | pressupost |
|----|------------|------------|
| 1  | Vendes     | 150000     |
| 2  | IT         | 200000     |
| 3  | Màrqueting | 100000     |

**Exercicis:**

1. Troba els empleats que guanyen més que la mitjana de l'empresa

2. Troba els empleats del departament amb el pressupost més alt

3. Troba els empleats que guanyen més que el seu supervisor

4. Troba els departaments que NO tenen empleats

5. Troba l'empleat amb el salari més alt de cada departament

6. Compte quants empleats té cada departament (utilitzant subconsulta a SELECT)

7. Troba els empleats que guanyen més que TOTS els empleats del departament de Vendes

8. Troba els departaments on el salari mitjà dels empleats supera 35000

### Solucions

<details>
<summary>Fes clic per veure les solucions</summary>

```sql
-- 1. Empleats per sobre la mitjana
SELECT nom, cognom, salari
FROM Empleats
WHERE salari > (SELECT AVG(salari) FROM Empleats);

-- 2. Empleats del departament amb més pressupost
SELECT nom, cognom, departament
FROM Empleats
WHERE departament = (
    SELECT nom
    FROM Departaments
    ORDER BY pressupost DESC
    LIMIT 1
);

-- 3. Empleats que guanyen més que el seu supervisor
SELECT e1.nom, e1.cognom, e1.salari
FROM Empleats e1
WHERE e1.salari > (
    SELECT e2.salari
    FROM Empleats e2
    WHERE e2.id = e1.supervisor_id
);

-- 4. Departaments sense empleats
SELECT nom
FROM Departaments d
WHERE NOT EXISTS (
    SELECT 1
    FROM Empleats e
    WHERE e.departament = d.nom
);

-- 5. Empleat amb salari més alt per departament
SELECT nom, cognom, departament, salari
FROM Empleats e1
WHERE salari = (
    SELECT MAX(salari)
    FROM Empleats e2
    WHERE e2.departament = e1.departament
);

-- 6. Comptar empleats per departament amb subconsulta
SELECT 
    d.nom,
    (SELECT COUNT(*) 
     FROM Empleats e 
     WHERE e.departament = d.nom) AS num_empleats
FROM Departaments d;

-- 7. Empleats que guanyen més que TOTS els de Vendes
SELECT nom, cognom, salari
FROM Empleats
WHERE salari > ALL (
    SELECT salari
    FROM Empleats
    WHERE departament = 'Vendes'
);

-- 8. Departaments amb salari mitjà > 35000
SELECT nom
FROM Departaments d
WHERE 35000 < (
    SELECT AVG(salari)
    FROM Empleats e
    WHERE e.departament = d.nom
);
```

</details>

## Resum

En aquesta sessió hem après:

- Què són les **subconsultes** i quan utilitzar-les
- **Subconsultes escalars** (retornen un valor)
- **Subconsultes amb múltiples valors** (IN, ANY, ALL)
- **Subconsultes correlacionades** (fan referència a la consulta externa)
- Subconsultes a **FROM**, **SELECT** i **HAVING**
- L'operador **EXISTS** i **NOT EXISTS**
- Comparació entre **subconsultes i JOINs**
- **Consideracions de rendiment**
- **Errors comuns** i com evitar-los

Les subconsultes són una eina poderosa que permet resoldre problemes complexos de manera elegant. Combinades amb JOINs, GROUP BY i altres clàusules, permeten fer consultes molt sofisticades.

---